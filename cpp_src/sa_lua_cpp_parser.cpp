/*
 * This file was auto-generated by speedy-antlr-tool v1.4.3
 *  https://github.com/amykyta3/speedy-antlr-tool
 */

#define PY_SSIZE_T_CLEAN
#include <Python.h>

#include <cstring>
#include <any>

#include "antlr4-runtime.h"
#include "LuaLexer.h"
#include "LuaParser.h"
#include "speedy_antlr.h"

#include "sa_lua_translator.h"
antlr4::tree::ParseTree* get_parse_tree_start_(LuaParser *parser) {return parser->start_();}
antlr4::tree::ParseTree* get_parse_tree_chunk(LuaParser *parser) {return parser->chunk();}
antlr4::tree::ParseTree* get_parse_tree_block(LuaParser *parser) {return parser->block();}
antlr4::tree::ParseTree* get_parse_tree_stat(LuaParser *parser) {return parser->stat();}
antlr4::tree::ParseTree* get_parse_tree_attnamelist(LuaParser *parser) {return parser->attnamelist();}
antlr4::tree::ParseTree* get_parse_tree_attrib(LuaParser *parser) {return parser->attrib();}
antlr4::tree::ParseTree* get_parse_tree_retstat(LuaParser *parser) {return parser->retstat();}
antlr4::tree::ParseTree* get_parse_tree_label(LuaParser *parser) {return parser->label();}
antlr4::tree::ParseTree* get_parse_tree_funcname(LuaParser *parser) {return parser->funcname();}
antlr4::tree::ParseTree* get_parse_tree_varlist(LuaParser *parser) {return parser->varlist();}
antlr4::tree::ParseTree* get_parse_tree_namelist(LuaParser *parser) {return parser->namelist();}
antlr4::tree::ParseTree* get_parse_tree_explist(LuaParser *parser) {return parser->explist();}
antlr4::tree::ParseTree* get_parse_tree_exp(LuaParser *parser) {return parser->exp();}
antlr4::tree::ParseTree* get_parse_tree_var(LuaParser *parser) {return parser->var();}
antlr4::tree::ParseTree* get_parse_tree_prefixexp(LuaParser *parser) {return parser->prefixexp();}
antlr4::tree::ParseTree* get_parse_tree_functioncall(LuaParser *parser) {return parser->functioncall();}
antlr4::tree::ParseTree* get_parse_tree_args(LuaParser *parser) {return parser->args();}
antlr4::tree::ParseTree* get_parse_tree_functiondef(LuaParser *parser) {return parser->functiondef();}
antlr4::tree::ParseTree* get_parse_tree_funcbody(LuaParser *parser) {return parser->funcbody();}
antlr4::tree::ParseTree* get_parse_tree_parlist(LuaParser *parser) {return parser->parlist();}
antlr4::tree::ParseTree* get_parse_tree_tableconstructor(LuaParser *parser) {return parser->tableconstructor();}
antlr4::tree::ParseTree* get_parse_tree_fieldlist(LuaParser *parser) {return parser->fieldlist();}
antlr4::tree::ParseTree* get_parse_tree_field(LuaParser *parser) {return parser->field();}
antlr4::tree::ParseTree* get_parse_tree_fieldsep(LuaParser *parser) {return parser->fieldsep();}
antlr4::tree::ParseTree* get_parse_tree_number(LuaParser *parser) {return parser->number();}
antlr4::tree::ParseTree* get_parse_tree_string(LuaParser *parser) {return parser->string();}

antlr4::tree::ParseTree* get_parse_tree(LuaParser *parser, const char *entry_rule_name) {
    static std::map<std::string, antlr4::tree::ParseTree* (*)(LuaParser*)> table
    {
        {"start_", &get_parse_tree_start_},
        {"chunk", &get_parse_tree_chunk},
        {"block", &get_parse_tree_block},
        {"stat", &get_parse_tree_stat},
        {"attnamelist", &get_parse_tree_attnamelist},
        {"attrib", &get_parse_tree_attrib},
        {"retstat", &get_parse_tree_retstat},
        {"label", &get_parse_tree_label},
        {"funcname", &get_parse_tree_funcname},
        {"varlist", &get_parse_tree_varlist},
        {"namelist", &get_parse_tree_namelist},
        {"explist", &get_parse_tree_explist},
        {"exp", &get_parse_tree_exp},
        {"var", &get_parse_tree_var},
        {"prefixexp", &get_parse_tree_prefixexp},
        {"functioncall", &get_parse_tree_functioncall},
        {"args", &get_parse_tree_args},
        {"functiondef", &get_parse_tree_functiondef},
        {"funcbody", &get_parse_tree_funcbody},
        {"parlist", &get_parse_tree_parlist},
        {"tableconstructor", &get_parse_tree_tableconstructor},
        {"fieldlist", &get_parse_tree_fieldlist},
        {"field", &get_parse_tree_field},
        {"fieldsep", &get_parse_tree_fieldsep},
        {"number", &get_parse_tree_number},
        {"string", &get_parse_tree_string}
    };

    auto entry = table.find(entry_rule_name);
    if (entry != table.end()) {
        return (*(entry->second))(parser);
    } else {
        PyErr_SetString(PyExc_ValueError, "Invalid entry_rule_name");
        throw speedy_antlr::PythonException();
    }
}

/*
 * Python function prototype:
 *  do_parse(
 *      parser_cls:antlr4.Parser,
 *      stream:antlr4.InputStream,
 *      entry_rule_name:str,
 *      sa_err_listener:SA_ErrorListener
 *  )
 */
PyObject* do_parse(PyObject *self, PyObject *args) {
    PyObject *strdata = NULL;
    PyObject *result = NULL;
    PyObject *token_module = NULL;

    try {
        // Get args
        PyObject *parser_cls = NULL;
        PyObject *stream = NULL;
        const char *entry_rule_name = NULL;
        PyObject *sa_err_listener = NULL;
        if(!PyArg_ParseTuple(args,
            "OOsO:do_parse",
            &parser_cls, &stream, &entry_rule_name, &sa_err_listener
        )) {
            return NULL;
        }

        // Extract input stream's string
        const char *cstrdata;
        Py_ssize_t bufsize;
        strdata = PyObject_GetAttrString(stream, "strdata");
        if(!strdata) throw speedy_antlr::PythonException();
        cstrdata = PyUnicode_AsUTF8AndSize(strdata, &bufsize);
        if(!cstrdata) throw speedy_antlr::PythonException();

        // Create an antlr InputStream object
        antlr4::ANTLRInputStream cpp_stream(cstrdata, bufsize);

        // in case error listener is overridden
        token_module = PyImport_ImportModule("antlr4.Token");
        if(!token_module) throw speedy_antlr::PythonException();
        speedy_antlr::Translator translator(parser_cls, stream);
        speedy_antlr::ErrorTranslatorListener err_listener(&translator, sa_err_listener);

        // Lex
        LuaLexer lexer(&cpp_stream);
        if(sa_err_listener != Py_None){
            lexer.removeErrorListeners();
            lexer.addErrorListener(&err_listener);
        }
        antlr4::CommonTokenStream token_stream(&lexer);
        token_stream.fill();

        // Parse
        LuaParser parser(&token_stream);
        if(sa_err_listener != Py_None){
            parser.removeErrorListeners();
            parser.addErrorListener(&err_listener);
        }
        antlr4::tree::ParseTree *parse_tree;
        parse_tree = get_parse_tree(&parser, entry_rule_name);

        // Translate Parse tree to Python
        SA_LuaTranslator visitor(&translator);
        result = std::any_cast<PyObject *>(visitor.visit(parse_tree));

        // Clean up data
        Py_XDECREF(token_module);
        Py_XDECREF(strdata);

        return result;

    } catch(speedy_antlr::PythonException &e) {
        Py_XDECREF(token_module);
        Py_XDECREF(strdata);
        Py_XDECREF(result);

        // Python exception already has error indicator set
        return NULL;
    } catch(...) {
        Py_XDECREF(token_module);
        Py_XDECREF(strdata);
        Py_XDECREF(result);

        // An internal C++ exception was thrown.
        // Set error indicator to a generic runtime error
        PyErr_SetString(PyExc_RuntimeError, "Internal error");
        return NULL;
    }
}


extern "C" {

    static PyObject* c_do_parse(PyObject *self, PyObject *args) {
        return do_parse(self, args);
    }

    static PyMethodDef methods[] = {
        {
            "do_parse",  c_do_parse, METH_VARARGS,
            "Run parser"
        },
        {NULL, NULL, 0, NULL} /* Sentinel */
    };

    static struct PyModuleDef module = {
        PyModuleDef_HEAD_INIT,
        "sa_lua_cpp_parser",   /* name of module */
        NULL, /* module documentation, may be NULL */
        -1,       /* size of per-interpreter state of the module,
                    or -1 if the module keeps state in global variables. */
        methods
    };
}


PyMODINIT_FUNC
PyInit_sa_lua_cpp_parser(void) {
    PyObject *m = PyModule_Create(&module);
    return m;
}